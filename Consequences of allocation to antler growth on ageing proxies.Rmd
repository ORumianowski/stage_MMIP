---
title: "Consequences of allocation to antler growth on epigenetic age acceleration and telomere dynamics"
date: "16/05/2022"
output: 
  html_document:
    theme: simplex
    toc: yes 
    toc_float: yes
encoding: UTF-8
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```


```{r}
rm(list = ls()) # nettoyage de l'environnement de travail


# Chargement du jeu de données --------------------------------------------

library(readxl) # pour charger les fichiers excel
library(tidyr)
library(tibble)
library(dplyr)
library(purrr)
library(ggplot2)
library(lme4)
library(naniar)
library(UpSetR)
library(corrplot)
library(stringr)
library(emmeans)
library(cowplot)

```

Odin Rumianowski$^1$$^2$ , Pierre Gloaguen$^1$, Jean-François Lemaître$^2$.

$^1$ AgroParisTech, UMR MIA 518
$^2$ Université	Lyon	1, CNRS,Laboratoire	de	Biométrie	et	Biologie	Evolutive	UMR5558

# INTRODUCTION

Evolutionary theories of senescence, *i.e.* Antagonistic Pleiotropic Theory or Disposable Soma Theory, consider that aging emerges from the trade-off between reproduction in early life and in late life (see Lemaître et al. 2015 for a review). 
Therefore, because sexual selection is associated with a diversity of cost (Garratt & Brooks, 2012), high allocation to precopulatory competition, including production and maintenance of secondary sexual traits (SST), is expected to correlate with senescence intensity. 
In mammals, the strength of sexual selection negatively influences the onset of senescence, and males of  polygynous species have an earlier onset of senescence than in monogamous species (Clutton-Brock & Isvaran 2007; Tidière et al., 2015). 
From an intraspecific perspective, sexual selection  might explained partially between-sex difference in senescence pattern. 
Males with a high investment in precopulatory behavior suffer from a strengthened senescence. 
For instance, in red deer, males which had larger harems experienced higher rates of senescence in both harem size and rut duration (Lemaître et al., 2014). 
Studies on  the cost associated with the development of SST have revealed diverse physiological costs (Garratt & Brooks, 2012). 
However, long-term costs were only unveiled from demographic studies (Lemaître et al., 2018) and very few studies have brought information able to determine if these long-term costs are physiological and what are the underlying mechanisms. 

A first approach to fill this gap is to establish if the intensity of production and maintenance of SST affects proxies of aging. 
For example, in the Australian painted dragon (*Ctenophorus pictus*), males that maintained a high level of head coloration suffered from a rapid rate of telomere loss  (Giraudeau et al., 2016). Although the relation between telomere dynamics and individual life history is still highly discussed, telomere shortening correlates with increased mortality risk and is usually perceived as a good biomarker for explaining reproductive costs (Sudyka, 2019).  
Another promising proxy of biological aging is the highly accurate epigenetic age estimators based on the level of cytosine methylation (Parrott and Bertucci, 2019). 
By interpreting the degree of epigenetic-to-chronological age discordance as a result of individual age acceleration, it can be used to quantify physiological long-term cost (Gibson et al. 2019).

In the present study, we tested the relationship between the allocation to antler growth and these two proxies of aging *i.e.* telomere dynamics and epigenetic age acceleration in roe deer (*Capreolus capreolus*), using a dataset from two French population measured in 2016 and 2017. 

# MATERIALS AND METHODS

## Study populations

We studied two roe deer populations living in two enclosed forests with markedly different environmental contexts: Trois-Fontaines (here after TF) and Chizé (CH). 
The Trois-Fontaines forest (1360 ha) is located in north-eastern France (48°43'N, 4°55'E) and is characterized by a continental climate, moderately severe winters and warm and rainy summers. This site has rich soils and provides high quality habitat for roe deer (Pettorelli et al., 2006). 
In contrast, the Chizé forest (2614 ha) is located in western France (46°50'N, 0°25'W) and is characterized by temperate oceanic climate with Mediterranean influences. 
This site has a low productivity due to poor quality soils and frequent summer droughts (Pettorelli et al., 2006), and thereby provides a quite poor habitat for roe deer in most years. 
Individuals from these two populations have been intensively monitored using a long-term Capture-Mark-Recapture programme since 1975 and 1977 (for Trois-Fontaines and Chizé, respectively). 
At each site, 10–12 days of capture using drive-netting are organized every year between December and March (see Gaillard et al., 1993 for details on capture sessions), which allows capturing and measuring about half of the population every year. 
Once a roe deer is captured, its sex and body mass (to the nearest 50 g) are recorded and a basic clinical examination is performed. 
All individuals included in our analyses were of known age because they were either caught as newborn in spring (see Delorme et al., 1988 for further details) or as 8 months old during winter captures, when they still have their milk teeth (most often incisors and always premolars, Flerov, 1952). Individuals are equipped with individually recognizable ear-tags and collars (either numbered, VHF or GPS collars), get a unique id, and are closely monitored throughout their lifetime using subsequent winter captures and observations in the field.

## DNA methylation data

The DNA methylation data used in this study was generated using the custom Illumina chip "HorvathMammalMethylChip40". The mammalian methylation array is attractive because it provides very high coverage of highly conserved CpGs in mammals (Arneson et al., 2021). Each probe is designed to cover a certain subset of species, such that overall all species have a high number of probes (Arneson et al., 2021). The particular subset of species for each probe is provided in the chip manifest file can be found at Gene Expression Omnibus (GEO) at NCBI as platform GPL28271 and on the GitHub page reported in our section on data availability. The SeSaMe normalization method was used to define beta values (methylation levels) for each CpG (Zhou et al., 2018). The SeSaMe normalization applies to one sample at a time.

```{r}
data_antler = read_excel("data/Dataset_ODIN_160422.xlsx", skip = 0, na = "NA") %>% 
  mutate(PlateNumber = as.factor(PlateNumber), 
         Batch_number = as.factor(Batch_number),
         ProblemDNA_Concentration = as.factor(ProblemDNA_Concentration),
         PlateTelomere  = as.factor(PlateTelomere),
         DNAmAgeLOO = as.numeric(DNAmAgeLOO),
         `AgeAccelLOO(ComputedUCLA)` = as.numeric(`AgeAccelLOO(ComputedUCLA)`),
         RightAntlerLength    = str_remove(RightAntlerLength, "_broken") %>% 
           as.numeric(),
         AntlerLength = map2_dbl(.x = Left_AntlerLength, 
                                 .y = RightAntlerLength,
                                 .f = function(x, y){
                                   if(is.na(x))
                                     return(y)
                                   else if(is.na(y))
                                     return(x)
                                   else
                                     return(max(x, y))
                                 }
         ),
         AgeClass = cut(Age, breaks = c(0,1,4,8,25)) %>% 
           as.character(),
         Age_2 = Age**2,
         Age_log = log((Age)),
         Cohort = factor(Cohort)) %>% 
  rename(Year = YearCapture,
         Day = JulianCaptureDate,
         Cohort_Type = `Cohort_Quality_Type(Good/Bad)`,
         DNAmAge = DNAmAgeLOO,
         AgeAccelLOO = `AgeAccelLOO(ComputedUCLA)`,
         Weight = WeightAnimal.kg,
         ProblemDNA  = ProblemDNA_Concentration,
         RTL = QC_RTL) %>% 
  select(Pop_Id, Year, Day, 
         Cohort, Cohort_Type, Population, 
         Age, Age_2, Age_log, AgeClass, Weight, AntlerLength, AntlerType,
         RTL, DNAmAge, AgeAccelLOO, ProblemDNA)


```



```{r}
# Problem with the sample
data_antler = data_antler[-which(data_antler$Pop_Id=="CM2301" & data_antler$Year=="2016") , ]
# Problem with the sample (Female)
data_antler = data_antler[-which(data_antler$Pop_Id=="TM368" & data_antler$Year=="2018") , ]
# Unmeasured Antler Length
data_antler = data_antler[-which(data_antler$Pop_Id=="CM2317" & data_antler$Year=="2016") , ]
data_antler = data_antler[-which(data_antler$Pop_Id=="TM3069" & data_antler$Year=="2018") , ]


data_antler_used_std =select(data_antler, 
    Pop_Id, 
    Year,
    Day,
    AntlerLength,
    AntlerType,
    AgeClass,
    Population) 
```

## How to measure allocation to antler growth

Antlers grow each year from the end of November until early March (i.e. before the velvet is shed).  Roe deer are in hard antler until the end of October/early November when	 they cast their antlers (Sempéré & Boissin, 1981). During their first year of life, males develop a small “button” (i.e. a very short	antler	with a	round	 top instead	of	a	spike) on	top	of their pedicle before growing	their first full antlers at	1	year of	age (Figure	1).	
Then,	males	generally	 develop	a	four-point	(in	yearlings) 	or	five-/six-point	(in	adults) head.	 Antler length	was	measured to	the nearest	0.5cm	along the	external side	of the main	beam,	from the	 base of	the	 antler to the top of	the	main beam	(Vanpé	et	al.,	2007). 
Antler	 length	 was	used	as	a	proxy	for	allocation	to	antler	growth	because	there	 is	a	strong	covariation	 among the different antler	traits in	deer (Lemaître	et	al., 2014).	 
When	an individual was	caught	more than	 once	in a	given	year,	only the	last measure	was	considered. 
When both	antlers	were intact, the average length	was	computed	and	retained for	the	analyses.	
When	one	antler	was	broken,	the	value	of the	remaining	intact	antler	was	retained.	When	both	antlers	were broken, the individual was removed from the dataset.	 

To obtain a measure of antler length independent from the date of capture, we used a standardization method used by Lemaître (2018). 
We analysed the	relationship between antler length and	the	Julian date	of capture	(with	1	December	as day	0).	

!!!!!!!!!!!!!!!!!!!!!!!!!
DANS CE QUI SUIT, TU DEVRAIS DIRE QUE TU AS REPRODUIT l'ANALYSE. Je n'aime pas le "As	antler growth	is a nonlinear process" suivi du "on ajuste plusieurs modèles dont une droite"
!!!!!!!!!!!!!!!!!!!!!!!!!

As	antler growth	is a nonlinear process (Goss, 1983), we fitted	different	functions	to	assess	reliably	the	shape	of the relationship between	antler length	(log-transformed) and date	of	capture :	constant,	linear,	a	threshold	 function	 with	 one	 slope	 (i.e.	 antler length	 increasing linearly with	date of	capture until reaching a plateau at a	given	date)	and a	threshold	 function with two slopes (i.e. antler length increasing	linearly	with	date	of	capture	until	a	given	date and then	increasing further, but	with	a	different	slope).	
To estimate these threshold values, the	deviance profile of	the	models including the slopes	was	used and the date	of	capture providing the lowest deviance	was	selected as the	threshold	value (Ulm	&	Cox,	1989).	
Model	selection	was	based	on the Akaike	Information	Criterion	(AIC). 

!!!!!!!!!!!!!!!!!!!!!!!!!
ECRIT CE QU'EST l'AIC et décrit en quelques mots quel est son rôle (compromis pouvoir explicatif/parcimonie)
!!!!!!!!!!!!!!!!!!!!!!!!!

!!!! LE  PARAGRAPHE SUIVANT DEVRAIT ETRE DANS LA PARTIE RESULTATS A MON AVIS, TU AS DECRIT LA METHODE DE STANDARDISATION, TU DECRIS DANS LA PARTIE RESULTATS CE QUE CA A DONNE !!!!!!!!!!!!!!!!


The models are tested on the data by discriminating according to the population of origin and whether the measurement was performed on a first year or not *i.e.* partitioning the dataset into four.
Measurements made on individuals with dry wood were removed from the analysis. 
The raw measurement will be used directly as a standard measurement. !!!!!!!!!! CETTE DERNIERER PHRASE ME SEMBLE EN CONTRADICTION AVEC LA STANDARDISATION PROPOSEE PLUS HAUT, NON? !!!!!!!!!!!
In order to retain as much data as possible, measurements of antlers where the antler condition is unknown were included in the standardization process.
The AIC and graph analysis reveal that the linear model is the best fit, except for the group of adults from Chizé where the best model corresponds to the constant function. 
For this group, the raw measure will be directly used as the standard measure.


```{r}

n = 1000
X = abs(rnorm(n))
Y = rnorm(length(X), sd = .5)



# Fonctions de standardisation --------------------------------------------

DATE_REF = 60

std_antler = function(antler_length, date, pars, date_ref = DATE_REF) {
  a = pars[1]
  b = pars[2]
  (antler_length - (a * date + b))  + a * date_ref + b
}

# Définition des fonctions de modélisation de la longueur des bois --------

# fonction constante

constante = function(pars, x) {
  a = pars[1]
  
  a
}

# fonction linéaire

lineaire = function(pars, x = 0) {
  a = pars[1]
  b = pars[2]
  
  a * x + b
}

# fonction de seuil avec une pente et un plateau

one_slope = function(pars, x) {
  a = pars[1]
  b = pars[2]
  seuil = pars[3]
  
  ifelse(x < seuil, a * x + b, a * seuil + b)
}

# fonction de seuil avec deux pentes

two_slopes = function(pars, x) {
  a = pars[1]
  b = pars[2]
  seuil = pars[3]
  c = pars[4]
  OO_2 = (a - c) * seuil + b
  
  ifelse(test = x < seuil,
         yes = a * x + b,
         no = c * x + OO_2)
}
```


```{r}

# Fonction d'optimisation par MV ------------------------------------------

plan_experience = tibble(
  ma_fonction = c(constante, lineaire, one_slope, two_slopes),
  initial_pars = list(c(0, 1), c(1, 0, 1), c(1, 0, 1, 1), c(1, 0, 0, 2, 1))
)

NLL = function(pars,
               ma_fonction,
               y = Y,
               x = X) {
  # Values predicted by the model
  sigma = pars[length(pars)]
  parametres_moyenne = pars[-length(pars)]
  Gpred = ma_fonction(parametres_moyenne, x)
  # Negative log-likelihood 
  -sum(dnorm(
    x = y,
    mean = Gpred,
    sd = sigma,
    log = TRUE
  ))
}

get_AIC = function(initial_pars,
                   ma_fonction,
                   y = Y,
                   x = X) {
  neg_log_lik = optim(
    par = initial_pars,
    fn = function(p)
      NLL(
        p,
        ma_fonction = ma_fonction,
        y = Y,
        x = X
      ),
    hessian = TRUE
  )$value
  2 * neg_log_lik + 2 * length(initial_pars)
}

optim_output = optim(
  par = c(1, 0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = lineaire,
      y = Y,
      x = X
    )
)
```

```{r, , fig.height=3, fig.width=4, echo = FALSE}

# Application aux données réelles -----------------------------------------

# CHIZE -------------------------------------------------------------------

# Premiere classe ---------------------------------------------------------

data_antler_2 = subset(data_antler_used_std, AntlerType == "BV" | is.na(AntlerType)) %>%
  subset(AgeClass == "(0,1]" & Population == "C" & AntlerLength > 1) # Les bois inf. à 1 sont considérer comme invariants

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()

optim_output = optim(
  par = c(1, 0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = lineaire,
      y = Y,
      x = X
    )
)

ggplot(data_antler_2,
       aes(x = X,
           y = Y,
           color = AntlerType)) +
  geom_point() +
  
  geom_abline(slope = optim_output$par[1],
              intercept = optim_output$par[2],
              colour = "red")+
  labs( title = "Chizé - 1A",
        x= "Julian Capture Date",
        y= "Antler Length (log)")


data_antler_3 = mutate(data_antler_2,
                       Antler_std = exp(std_antler(
                         log(AntlerLength), Day, optim_output$par
                       )))


data_antler_1C = data_antler_3[, c("Pop_Id", "Year", "Antler_std")]


# Classes supérieures -----------------------------------------------------


data_antler_2 = subset(data_antler_used_std, AntlerType == "BV"| is.na(AntlerType)) %>%
  subset(AgeClass != "(0,1]" & Population == "C") 

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()


optim_output = optim(
  par = c(0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = constante,
      y = Y,
      x = X
    )
)


ggplot(data_antler_2,
       aes(x = X,
           y = Y,
           color = AntlerType)) +
  geom_point() +
  
  geom_abline(slope = 0,
              intercept = optim_output$par[1],
              colour = "red")  +
  labs( title = "Chizé - +1A",
        x= "Julian Capture Date",
        y= "Antler Length (log)")


data_antler_3 = mutate(data_antler_2,
                       Antler_std = AntlerLength)


data_antler_NC = data_antler_3[, c("Pop_Id", "Year", "Antler_std")]

# Trois Fontaines ---------------------------------------------------------

# Premiere classe ---------------------------------------------------------

data_antler_2 = subset(data_antler_used_std,AntlerType == "BV" | is.na(AntlerType)) %>%
  subset(AgeClass == "(0,1]" & Population == "TF") 

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()

optim_output = optim(
  par = c(1, 0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = lineaire,
      y = Y,
      x = X
    )
)

ggplot(data_antler_2,
       aes(x = X,
           y = Y,
           color = AntlerType)) +
  geom_point() +
  
  geom_abline(slope = optim_output$par[1],
              intercept = optim_output$par[2],
              colour = "red")+
  labs( title = "Trois-Fontaines - 1A",
        x= "Julian Capture Date",
        y= "Antler Length (log)")


data_antler_3 = mutate(data_antler_2,
                       Antler_std = exp(std_antler(
                         log(AntlerLength), Day, optim_output$par
                       )))


data_antler_1TF = data_antler_3[, c("Pop_Id", "Year", "Antler_std")]


# Classes supérieures -----------------------------------------------------


data_antler_2 = subset(data_antler_used_std, AntlerType == "BV" | is.na(AntlerType)) %>%
  subset(AgeClass != "(0,1]" & Population == "TF") 

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()

optim_output = optim(
  par = c(1, 0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = lineaire,
      y = Y,
      x = X
    )
)

ggplot(data_antler_2,
       aes(x = X,
           y = Y,
           color = AntlerType)) +
  geom_point() +
  
  geom_abline(slope = optim_output$par[1],
              intercept = optim_output$par[2],
              colour = "red")+
  labs( title = "Trois-Fontaines - +1A",
        x= "Julian Capture Date",
        y= "Antler Length (log)")


data_antler_3 = mutate(data_antler_2,
                       Antler_std = exp(std_antler(
                         log(AntlerLength), Day, optim_output$par
                       )))

data_antler_NTF = data_antler_3[, c("Pop_Id", "Year", "Antler_std")]

data_antler_std = rbind(data_antler_1C,
                        data_antler_NC,
                        data_antler_1TF,
                        data_antler_NTF)

data_antler_complet <-  merge(data_antler_used_std, data_antler_std, by=c("Pop_Id", "Year"), all.x = TRUE)


# Traitement des cas Antler_Type==BD  & AntlerLength <= 1 --------------------

for (k in 1:nrow(data_antler_complet)){
  if (!is.na(data_antler_complet[k, "AntlerType"])){
    if (data_antler_complet[k, "AntlerType"] == "BD"){ 
      data_antler_complet[k, "Antler_std"] = data_antler_complet[k, "AntlerLength"]
    }
  }
  if (data_antler_complet[k, "AntlerLength"] <= 1){
    data_antler_complet[k, "Antler_std"] = data_antler_complet[k, "AntlerLength"]
  }
}

data_antler_complet <- data_antler_complet[,c("Pop_Id", "Year", "Antler_std")]
data_antler <-  merge(data_antler, data_antler_complet, by=c("Pop_Id", "Year"), all.x = TRUE)

```

## How to measure epigenetic age acceleration

Because methylation dynamics are more active during development, epigenetic age does not evolve in a linear fashion. 
Following Horvath (2013), we computed the epigenetic acceleration as the residuals of the models that best described the relationship between DNAm!!!!! PARLE ANGLAIS DANS LES PHRASES DNAm, CEST MOCHE!!!! age and chronological age.  
!!!! ICI CEST TYPIQUEMENT UNE PHRASE VAGUE QUIL FAUT FORMALISER JE TE PROPOSE UN TRUC DE CE GENRE!!!

Formally, we suppose that there exists a $f$ such that:
$$\text{Methylated Age} = f(Age) + E,$$
where $f$ is a prediction function (potentially emerging from a physical model), and $E$ is a remainder that we call *residual*.

Four functions were proposed and we used a tenfold cross validation to compare them. The model with a simple logarithmic component was selected. The different functions	were: 
\begin{align*}
f_1(Age) &= \alpha + \beta \times Age \\
f_2(Age) &= \alpha \times \log(Age + 1) + \beta \times Age\\
f_3(Age) &= \alpha \times \log(Age+1), Age < adult.age
f_3(Age) &= \beta \times \frac{ Age-adult.age}{adult.age + 1} + \alpha \times log(adult.age+1) , Age>adult.age
f_4(Age) &= \alpha \times Age + \beta \times Age^2
\end{align*}





```{r}
rm(list = ls()) # nettoyage de l'environnement de travail
source("utils_packages.R")
source("script_pretraitement_data_antler.R")
```
```{r}

data_antler = select(data_antler, Age,  DNAmAge) %>% 
  na.omit()

# Definition de la fonction de cout pour n'importe quel predicteur

cost_function <- function(parametre, predicteur, my_data = data_antler){
  sum(map2_dbl(.x = my_data$Age, .y = my_data$DNAmAge, function(x, y) (y - predicteur(parametre, x))^2))
}


# Predicteur Lineaire ---------------------------------------------------------

predicteur_Lineaire <- function(parametre, Age){
  alpha = parametre[1]
  beta <- parametre[2]
  
  alpha + beta * Age
}


# Predicteur log -------------------------------------------------------


predicteur_log <- function(parametre, Age){
  alpha = parametre[1]
  beta <- parametre[2]
  
  alpha * log(Age+1) + beta * Age
}


# Prédicteur Horvath ------------------------------------------------------

predicteur_Horvath = function(parametre, Age){
  
  alpha = parametre[1]
  beta <- parametre[2]
  adult.age <- parametre[3]
  
  
  alpha * log(Age+1) * (Age < adult.age) +
    (beta * (Age-adult.age)/(adult.age + 1) + alpha * log(adult.age+1)) * (Age>=adult.age)
  
}


# Prédicteur Quadratic ------------------------------------------------------

predicteur_Quadratic = function(parametre, Age){
  
  alpha = parametre[1]
  beta <- parametre[2]
  adult.age <- parametre[3]
  
  
  alpha * Age + beta * Age**2
}

# Representation graphique ------------------------------------------------

optimization_function = function(mon_predicteur, nb_par, nb_replicates = 10){
  rerun(nb_replicates,# On fait tourner nb_replicates fois le meme traitement
        {
          param = runif(nb_par, 0, 4) # Generation aleatoire du param initial
          # Optimisation a partir de ce parametre
          res_optim = optim(param, predicteur = mon_predicteur, 
                            cost_function, method = "Nelder-Mead")
          # Aggregation des resultats dans un tableau
          tibble(value = res_optim$value, par =  list(res_optim$par))
        }) %>% 
    bind_rows() %>% # Aggrege dans un tableau
    filter(value == min(value)) %>% # Filtre sur ceux qui atteignent le minimum
    slice(1) %>% # Prend la premiere ligne
    pull(par) %>% # On prend le parametre
    unlist() # On le met en vecteur
}
```
```{r}

cv_function = function(my_prop = 0.7, nb_replicates = 100){
  rerun(nb_replicates,# On fait tourner nb_replicates fois le meme traitement
        { 
          split_cv = initial_split(data_antler, prop=my_prop)
          
          train_data = analysis(split_cv)
          test_data = assessment((split_cv))
          
          par_Lineaire = optim(par = optimization_function(predicteur_Lineaire,nb_par = 2), 
                                   predicteur = predicteur_Lineaire, 
                                   my_data = train_data, 
                                   cost_function, 
                                   method = "Nelder-Mead")$par
          
          par_log = optim(par = optimization_function(predicteur_log,nb_par = 2), 
                                   predicteur = predicteur_log, 
                                   my_data = train_data, 
                                   cost_function, 
                                   method = "Nelder-Mead")$par
          
          par_Horvath = optim(par = optimization_function(predicteur_Horvath,nb_par = 3), 
                                    predicteur = predicteur_Horvath, 
                                    my_data = train_data, 
                                    cost_function, 
                                    method = "Nelder-Mead")$par
          
          par_Quadratic = optim(par = optimization_function(predicteur_Quadratic,nb_par = 2), 
                                    predicteur = predicteur_Quadratic, 
                                    my_data = train_data, 
                                    cost_function, 
                                    method = "Nelder-Mead")$par
          
          
          
          value_Lineaire = cost_function(par_Lineaire, predicteur_Lineaire, my_data = test_data)
          value_Log = cost_function(par_log, predicteur_log, my_data = test_data)
          value_Horvath = cost_function(par_Horvath, predicteur_Horvath, my_data = test_data)
          value_Quadratic = cost_function(par_Quadratic, predicteur_Quadratic, my_data = test_data)
          
          
          
          tibble(method = c("Lineaire", "Logarithmic", "Horvath", "Quadratic"),
                 performance = c(value_Lineaire, 
                                 value_Log,
                                 value_Horvath, 
                                 value_Quadratic))
          
          
        }) %>% 
    bind_rows(.id = "Replicate") 
}

```
```{r}
cv_res = cv_function(my_prop = 0.7, nb_replicates = 10)

```
```{r, fig.height=3, fig.width=4, echo = FALSE}
ggplot(data_antler) +
  aes(x = Age, y = DNAmAge) +
  geom_point()+
  stat_function(aes(color = "log"), 
                fun = predicteur_log, 
                args = list(parametre  = optimization_function(predicteur_log, 
                                                               nb_par = 2))) +
  stat_function(aes(color = "Horvath"), 
                fun = predicteur_Horvath, 
                args = list(parametre  = optimization_function(predicteur_Horvath, 
                                                               nb_par = 3))) +
  
  stat_function(aes(color = "Lineaire"), 
                fun = predicteur_Lineaire, 
                args = list(parametre  = optimization_function(predicteur_Lineaire, 
                                                               nb_par = 2))) + 
  stat_function(aes(color = "Quadratic"), 
                fun = predicteur_Quadratic, 
                args = list(parametre  = optimization_function(predicteur_Quadratic, 
                                                               nb_par = 2))) + 
  ggtitle("Tested models of DNAmAge \n  in relation to the Age")


ggplot(cv_res, aes(x=method, y=performance, color=method)) + 
  geom_boxplot()+ 
  geom_jitter(shape=16, position=position_jitter(0.01))+ 
  ggtitle("Cross-validation \n evaluating models of DNAmAge")
```

## Statistical analysis


All statistical analyses were performed in the R environment version 4.0.3. The selection of linear mixed models based on the AICc was carried out using the function “dredge” of the package MuMin.  For all analysis, antler length,  weight and population origin were used as explanatory variables. The cohort i.e. the birth date was added as a random effect. One individual with a null antler length was removed from the analysis. The antler length and the weight were log-transformed. All possible variable interactions were added (see Additional Information). Individuals were partitioned into four groups (1, 2-4, 5-7 and +7 years) to form the variable of age class. 

To test the relationship between antler length and the epigenetic age acceleration, a first model was applied on all individuals with no lacking data (88 individuals). The age class was added as an explanatory variable. A second model  was applied only on the fawn (27 individuals). 

Similarly, the relationship between antler length and the RTL was tested with a first model applied on all adults (123 individuals) and a second model only applied on the fawn. The relationship between antler length and the telomere dynamics was tested thanks to the recaptures of 25 individuals in the second year making access to an annual RTL variation possible. 


# RESULTS 

For all analyses concerning the relationship between epigenetic age acceleration and allocation to antler growth, the constant model was selected. For all analyses concerning the relationship between RTL and allocation to antler growth, the selected model contained the population origin as explanatory variable, with a difference of 0.43 (95% CI [-0.79 ; -0.06], P  =  0.021) between the two population, revealing the dependence of RTL to the population for roe deer.For all analyses concerning the relationship between RTL annual variation and allocation to antler growth, the constant model was selected.

```{r}
date_day = function(date){
  
  if (format(date, format = "%Y")=="2016"){
    startdate <- as.Date("01/12/2015","%d/%m/%Y")
    new_date = difftime(date,startdate ,units="days") %>% 
      as.integer()
    return(new_date)
  }
  
  if (format(date, format = "%Y")=="2017"){
    startdate <- as.Date("01/12/2016","%d/%m/%Y")
    new_date = difftime(date,startdate ,units="days")%>% 
      as.integer()
    return(new_date)
  }
}

data_antler = read_excel("data/Dataset_Telomere_Bois040522.xlsx", skip = 0, na = "NA") %>% 
  rename(RTL = QC_RTL,
         Population = population,
         AntlerType = State,
         Tbars = tbars,
         Id = Id_JM,
         Weight = Masse) %>% 
  mutate(Id = as.factor(Id),
         Year = as.factor(Year),
         Cohort = as.factor(Cohorte),
         Population = as.factor(Population),
         Sex = as.factor(Sex),
         AntlerType = as.factor(AntlerType),
         AntlerLength = map2_dbl(.x = Antler_left, 
                                 .y = Antler_right,
                                 .f = function(x, y){
                                   if(is.na(x))
                                     return(y)
                                   else if(is.na(y))
                                     return(x)
                                   else
                                     return(max(x, y))
                                 }
         ),
         Day = map_dbl(DateCapture, date_day),
         AgeClass = cut(Age, breaks = c(0,1,4,8,25))) %>% 
  dplyr::select(Id, Year, Day, Population, Weight,
                Cohort, Sex, Age, Tbars, RTL, AntlerLength, AntlerType, AgeClass) 

dcohort = read_excel("data/Dataset_ODIN_160422.xlsx", skip = 0, na = "NA") %>% 
  rename(Cohort_Quality_Pop = `CohortQuality/pop`) %>% 
  mutate(Population = as.factor(Population),
         Cohort = as.factor(Cohort), 
         Cohort_Quality_Pop = as.numeric(Cohort_Quality_Pop)) %>% 
  dplyr::select(Population, Cohort, Cohort_Quality_Pop) %>% 
  unique()

data_antler = merge(data_antler, dcohort, by=c("Population", "Cohort") , all.x = TRUE)



```


```{r}
# Problem with the sample
data_antler = data_antler[-which(data_antler$Id=="M2301" & data_antler$Year=="2016") , ]

# Unmeasured Antler Length
data_antler = data_antler[-which(data_antler$Id=="M2317" & data_antler$Year=="2016") , ]


data_antler_used_std =data_antler[,c("Id", 
                                     "Year",
                                     "Day",
                                     "AntlerLength",
                                     "AntlerType",
                                     "AgeClass",
                                     "Population")] %>% 
  subset(AntlerLength > 1)
                              


# Fonctions de standardisation --------------------------------------------

DATE_REF = 60

std_antler = function(antler_length, date, pars, date_ref = DATE_REF) {
  a = pars[1]
  b = pars[2]
  (antler_length - (a * date + b))  + a * date_ref + b
}

# Définition des fonctions de modélisation de la longueur des bois --------

# fonction constante

constante = function(pars, x) {
  a = pars[1]
  
  a
}

# fonction linéaire

lineaire = function(pars, x = 0) {
  a = pars[1]
  b = pars[2]
  
  a * x + b
}



NLL = function(pars,
               ma_fonction,
               y = Y,
               x = X) {
  # Values predicted by the model
  sigma = pars[length(pars)]
  parametres_moyenne = pars[-length(pars)]
  Gpred = ma_fonction(parametres_moyenne, x)
  # Negative log-likelihood 
  -sum(dnorm(
    x = y,
    mean = Gpred,
    sd = sigma,
    log = TRUE
  ))
}

get_AIC = function(initial_pars,
                   ma_fonction,
                   y = Y,
                   x = X) {
  neg_log_lik = optim(
    par = initial_pars,
    fn = function(p)
      NLL(
        p,
        ma_fonction = ma_fonction,
        y = Y,
        x = X
      ),
    hessian = TRUE
  )$value
  2 * neg_log_lik + 2 * length(initial_pars)
}


n = 1000
X = abs(rnorm(n))
Y = lineaire(c(2, 5, 1), X) + rnorm(length(X), sd = .5)


# CHIZE -------------------------------------------------------------------

# Premiere classe ---------------------------------------------------------

data_antler_2 = subset(data_antler_used_std, AntlerType == "BV" | is.na(AntlerType)) %>%
  subset(AgeClass == "(0,1]" & Population == "C")

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()

optim_output = optim(
  par = c(1, 0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = lineaire,
      y = Y,
      x = X
    ))

data_antler_1C = data_antler_2 %>% 
  mutate(Antler_std = std_antler(log(AntlerLength), Day, optim_output$par) %>% 
           exp()) %>% 
  dplyr::select(Id, Population, Year, Antler_std)
  


# Classes supérieures -----------------------------------------------------


data_antler_2 = subset(data_antler_used_std, AntlerType == "BV"| is.na(AntlerType)) %>%
  subset(AgeClass != "(0,1]" & Population == "C") 

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()


data_antler_NC = data_antler_2 %>% 
  mutate(Antler_std = AntlerLength) %>% 
  dplyr::select(Id, Population, Year, Antler_std)


# Trois Fontaines ---------------------------------------------------------

# Premiere classe ---------------------------------------------------------

data_antler_2 = subset(data_antler_used_std,AntlerType == "BV" | is.na(AntlerType)) %>%
  subset(AgeClass == "(0,1]" & Population == "TF") 

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()

optim_output = optim(
  par = c(1, 0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = lineaire,
      y = Y,
      x = X
    )
)

data_antler_1TF = data_antler_2 %>% 
  mutate(Antler_std = std_antler(log(AntlerLength), Day, optim_output$par) %>% 
           exp()) %>% 
  dplyr::select(Id, Population, Year, Antler_std)


# Classes supérieures -----------------------------------------------------


data_antler_2 = subset(data_antler_used_std, AntlerType == "BV" | is.na(AntlerType)) %>%
  subset(AgeClass != "(0,1]" & Population == "TF") 

X = data_antler_2$Day
Y = data_antler_2$AntlerLength %>%
  log()
optim_output = optim(
  par = c(1, 0, 1),
  fn = function(p)
    NLL(
      p,
      ma_fonction = lineaire,
      y = Y,
      x = X
    )
)

data_antler_NTF = data_antler_2 %>% 
  mutate(Antler_std = std_antler(log(AntlerLength), Day, optim_output$par) %>% 
           exp()) %>% 
  dplyr::select(Id, Population, Year, Antler_std)



# merge -------------------------------------------------------------------

data_antler_std = rbind(data_antler_1C,
                        data_antler_NC,
                        data_antler_1TF,
                        data_antler_NTF)

data_antler_complet <-  merge(data_antler_used_std, data_antler_std, by=c("Id", "Population","Year"), all.x = TRUE)


# Traitement des cas Antler_Type==BD  & AntlerLength <= 1 --------------------

for (k in 1:nrow(data_antler_complet)){
  if (!is.na(data_antler_complet[k, "AntlerType"])){
    if (data_antler_complet[k, "AntlerType"] == "BD"){ 
      data_antler_complet[k, "Antler_std"] = data_antler_complet[k, "AntlerLength"]
    }
  }
  if (data_antler_complet[k, "AntlerLength"] <= 1){
    data_antler_complet[k, "Antler_std"] = data_antler_complet[k, "AntlerLength"]
  }
}

data_antler_complet <- data_antler_complet[,c("Id", "Year", "Population", "Antler_std")]
data_antler <-  merge(data_antler, data_antler_complet, by=c("Id", "Year", "Population"), all.x = TRUE)


rm()
rm(k)
rm(n)
rm(X)
rm(Y)
rm(DATE_REF)
rm(optim_output)
rm(constante)
rm(date_day)
rm(get_AIC)
rm(lineaire)
rm(NLL)
rm(std_antler)
rm(data_antler_1C)
rm(data_antler_NC)
rm(data_antler_1TF)
rm(data_antler_NTF)
rm(data_antler_std)
rm(data_antler_complet)

rm(data_antler_2)
rm(data_antler_used_std)




```



```{r, fig.height=4, fig.width=5}
data_antler= mutate(data_antler,
                    RTL = scale(RTL))

ggplot(data_antler,
       aes(x = Population,
           y = RTL,
           color=Population)) +
  geom_boxplot()+ 
  geom_jitter(shape=16, position=position_jitter(0.05))+ 
  ggtitle("Relative Telomere Length  \n in relation to the Population")

```

# DISCUSSION

### REFERENCES

Clutton-Brock, T.H., Isvaran, K., 2007. Sex differences in ageing in natural populations of vertebrates. Proc. R. Soc. B. 274, 3097–3104. https://doi.org/10.1098/rspb.2007.1138

Garratt, M., Brooks, R.C., 2012. Oxidative stress and condition-dependent sexual signals: more than just seeing red. Proc. R. Soc. B. 279, 3121–3130. https://doi.org/10.1098/rspb.2012.0568

Gibson, J., Russ, T.C., Clarke, T.-K., Howard, D.M., Hillary, R.F., Evans, K.L., Walker, R.M., Bermingham, M.L., Morris, S.W., Campbell, A., Hayward, C., Murray, A.D., Porteous, D.J., Horvath, S., Lu, A.T., McIntosh, A.M., Whalley, H.C., Marioni, R.E., n.d. A meta-analysis of genome-wide association studies of epigenetic age acceleration 30.

Lemaître, J.-F., Gaillard, J.-M., Pemberton, J.M., Clutton-Brock, T.H., Nussey, D.H., 2014. Early life expenditure in sexual competition is associated with increased reproductive senescence in male red deer. Proc. R. Soc. B. 281, 20140792. https://doi.org/10.1098/rspb.2014.0792

Lemaître, J.-F., Berger, V., Bonenfant, C., Douhard, M., Gamelon, M., Plard, F., Gaillard, J.-M., 2015. Early-late life trade-offs and the evolution of ageing in the wild. Proc. R. Soc. B. 282, 20150209. https://doi.org/10.1098/rspb.2015.0209

Parrott, B.B., Bertucci, E.M., 2019. Epigenetic Aging Clocks in Ecology and Evolution. Trends in Ecology & Evolution 34, 767–770. https://doi.org/10.1016/j.tree.2019.06.008

Sudyka, J., 2019. Does Reproduction Shorten Telomeres? Towards Integrating Individual Quality with Life‐History Strategies in Telomere Biology. BioEssays 41, 1900095. https://doi.org/10.1002/bies.201900095

Tidière, M., Gaillard, J.-M., Müller, D.W.H., Lackey, L.B., Gimenez, O., Clauss, M., Lemaître, J.-F., 2015. Does sexual selection shape sex differences in longevity and senescence patterns across vertebrates? A review and new insights from captive ruminants: SEXUAL SELECTION AND SENESCENCE. Evolution 69, 3123–3140. https://doi.org/10.1111/evo.12801


### AUTHORS’ CONTRIBUTIONS 

J.F.L. conceived	the	ideas	 and	J.F.L. and P.G. designed	 methodology.	 O.R.	 analysed	 the	 data. O.R. wrote the manuscript, J.F.L.	 wrote	 the paragraphs "Study populations", "methylation data" and part of "How to measure allocation to antler growth".




